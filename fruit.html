<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ìˆ˜ë°• ê²Œì„ (Watermelon Game)</title>
    <!-- Matter.js ë¬¼ë¦¬ ì—”ì§„ ë¡œë“œ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        /* CSS ìŠ¤íƒ€ì¼ë§ */
        body {
            margin: 0;
            padding: 0;
            background-color: #ffeaa7;
            overflow: hidden; /* ìŠ¤í¬ë¡¤ ë°©ì§€ */
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: none; /* ëª¨ë°”ì¼ í„°ì¹˜ ì‹œ ë¸Œë¼ìš°ì € ê¸°ë³¸ ë™ì‘ ë°©ì§€ */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 450px; /* ëª¨ë°”ì¼ í­ ì œí•œ */
            height: 100vh;
            background: #fff;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* í´ë¦­ì€ ìº”ë²„ìŠ¤ë¡œ í†µê³¼ */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .score-board {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 25px;
            border-radius: 30px;
            font-size: 24px;
            font-weight: bold;
            color: #2d3436;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 2px solid #fab1a0;
        }

        .score-label {
            font-size: 14px;
            color: #636e72;
            display: block;
            text-align: center;
        }

        /* ê²Œì„ ì˜¤ë²„ í™”ë©´ */
        #game-over {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            flex-direction: column;
            pointer-events: auto;
            z-index: 10;
        }

        #game-over h1 {
            color: white;
            font-size: 40px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #restart-btn {
            padding: 15px 30px;
            font-size: 20px;
            background-color: #fab1a0;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 0 #e17055;
            transition: transform 0.1s;
        }

        #restart-btn:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        /* ë‹¤ìŒ ê³¼ì¼ í‘œì‹œ */
        #next-fruit-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.8);
            padding: 5px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #ffeaa7;
        }
        #next-fruit-label {
            font-size: 10px;
            color: #636e72;
        }
        #next-fruit-emoji {
            font-size: 30px;
        }
        
        #permission-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #aaa;
            font-size: 12px;
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui-layer">
        <div class="score-board">
            <span class="score-label">SCORE</span>
            <span id="score">0</span>
        </div>
        
        <div id="next-fruit-display">
            <div id="next-fruit-label">NEXT</div>
            <div id="next-fruit-emoji">ğŸ’</div>
        </div>
    </div>
    
    <div id="permission-hint">í™”ë©´ì„ í„°ì¹˜í•˜ë©´ ìì´ë¡œ ì„¼ì„œê°€ í™œì„±í™”ë©ë‹ˆë‹¤ (ëª¨ë°”ì¼)</div>

    <div id="game-over">
        <h1>ê²Œì„ ì¢…ë£Œ!</h1>
        <button id="restart-btn">ë‹¤ì‹œ í•˜ê¸°</button>
    </div>
</div>

<script>
    // --- ê²Œì„ ì„¤ì • ë° ë°ì´í„° ---
    const FRUITS = [
        { index: 0, name: "cherry",     radius: 15,  score: 0,   color: "#FF0000", emoji: "ğŸ’" },
        { index: 1, name: "strawberry", radius: 25,  score: 10,  color: "#FF6666", emoji: "ğŸ“" },
        { index: 2, name: "grape",      radius: 35,  score: 20,  color: "#9933FF", emoji: "ğŸ‡" },
        { index: 3, name: "dekopon",    radius: 45,  score: 30,  color: "#FFAA00", emoji: "ğŸŠ" },
        { index: 4, name: "persimmon",  radius: 55,  score: 40,  color: "#FF7700", emoji: "ğŸ¥­" },
        { index: 5, name: "apple",      radius: 68,  score: 50,  color: "#FF2222", emoji: "ğŸ" },
        { index: 6, name: "pear",       radius: 80,  score: 60,  color: "#FFFF66", emoji: "ğŸ" },
        { index: 7, name: "peach",      radius: 95,  score: 70,  color: "#FFCCCC", emoji: "ğŸ‘" },
        { index: 8, name: "pineapple",  radius: 110, score: 80,  color: "#FFFF00", emoji: "ğŸ" },
        { index: 9, name: "melon",      radius: 130, score: 90,  color: "#99FF99", emoji: "ğŸˆ" },
        { index: 10, name: "watermelon",radius: 150, score: 100, color: "#00FF00", emoji: "ğŸ‰" },
    ];

    // Matter.js ëª¨ë“ˆ ë³„ì¹­
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Events = Matter.Events,
          Body = Matter.Body,
          Vector = Matter.Vector;

    // ê²Œì„ ìƒíƒœ ë³€ìˆ˜
    let engine, render;
    let currentFruit = null;
    let nextFruitIndex = 0;
    let isDropping = false;
    let score = 0;
    let gameOver = false;
    let gameContainer = document.getElementById('game-container');
    let width = gameContainer.clientWidth;
    let height = gameContainer.clientHeight;
    
    // íŒŒí‹°í´ ì‹œìŠ¤í…œì„ ìœ„í•œ ë°°ì—´
    let particles = [];

    const WALL_THICKNESS = 40;
    const TOP_BUFFER = 100; 

    // ìì´ë¡œ ì„¼ì„œ ê´€ë ¨
    let isGyroEnabled = false;

    // ì´ˆê¸°í™” í•¨ìˆ˜
    function init() {
        engine = Engine.create();
        
        render = Render.create({
            element: gameContainer,
            engine: engine,
            options: {
                width: width,
                height: height,
                wireframes: false,
                background: 'transparent'
            }
        });

        // ë²½ ìƒì„±
        const ground = Bodies.rectangle(width / 2, height + WALL_THICKNESS / 2 - 10, width, WALL_THICKNESS, { isStatic: true, render: { fillStyle: '#b2bec3' } });
        const leftWall = Bodies.rectangle(0 - WALL_THICKNESS / 2, height / 2, WALL_THICKNESS, height * 2, { isStatic: true, render: { fillStyle: '#b2bec3' } });
        const rightWall = Bodies.rectangle(width + WALL_THICKNESS / 2, height / 2, WALL_THICKNESS, height * 2, { isStatic: true, render: { fillStyle: '#b2bec3' } });
        
        const dangerLine = Bodies.rectangle(width/2, TOP_BUFFER, width, 2, { 
            isStatic: true, 
            isSensor: true, 
            render: { fillStyle: '#fab1a0', opacity: 0.5 } 
        });

        Composite.add(engine.world, [ground, leftWall, rightWall, dangerLine]);

        // ë Œë”ë§ ì´ë²¤íŠ¸ (ì´ëª¨ì§€ ë° íŒŒí‹°í´ ê·¸ë¦¬ê¸°)
        Events.on(render, 'afterRender', function() {
            const context = render.context;
            const bodies = Composite.allBodies(engine.world);

            // 1. ê³¼ì¼ ì´ëª¨ì§€ ê·¸ë¦¬ê¸°
            for (let i = 0; i < bodies.length; i++) {
                const body = bodies[i];
                if (body.isStatic) continue;

                const fruitInfo = FRUITS.find(f => f.name === body.label);
                if (fruitInfo) {
                    context.font = `${fruitInfo.radius * 1.5}px Arial`;
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.save();
                    context.translate(body.position.x, body.position.y);
                    context.rotate(body.angle);
                    context.fillText(fruitInfo.emoji, 0, 5);
                    context.restore();
                }
            }
            
            // 2. íŒŒí‹°í´(í­ë°œ) íš¨ê³¼ ê·¸ë¦¬ê¸°
            updateAndDrawParticles(context);

            // 3. í˜„ì¬ ëŒ€ê¸° ì¤‘ì¸ ê³¼ì¼ í‘œì‹œ
            if (currentFruit && !isDropping) {
                const info = FRUITS[currentFruit.index];
                context.beginPath();
                context.moveTo(currentFruit.x, TOP_BUFFER);
                context.lineTo(currentFruit.x, height);
                context.strokeStyle = 'rgba(0,0,0,0.1)';
                context.stroke();

                context.font = `${info.radius * 1.5}px Arial`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(info.emoji, currentFruit.x, currentFruit.y);
            }
        });

        // ì¶©ëŒ ì´ë²¤íŠ¸
        Events.on(engine, 'collisionStart', function(event) {
            if (gameOver) return;

            const pairs = event.pairs;
            const removedBodies = new Set();

            for (let i = 0; i < pairs.length; i++) {
                const bodyA = pairs[i].bodyA;
                const bodyB = pairs[i].bodyB;

                if (removedBodies.has(bodyA.id) || removedBodies.has(bodyB.id)) continue;

                if (bodyA.label === bodyB.label) {
                    const fruitIndex = FRUITS.findIndex(f => f.name === bodyA.label);
                    
                    if (fruitIndex !== -1 && fruitIndex < FRUITS.length - 1) {
                        const midX = (bodyA.position.x + bodyB.position.x) / 2;
                        const midY = (bodyA.position.y + bodyB.position.y) / 2;

                        removedBodies.add(bodyA.id);
                        removedBodies.add(bodyB.id);

                        Composite.remove(engine.world, [bodyA, bodyB]);
                        
                        // ë‹¤ìŒ ë‹¨ê³„ ê³¼ì¼
                        const nextFruit = FRUITS[fruitIndex + 1];
                        
                        // í­ë°œ ì´í™íŠ¸ ìƒì„±
                        createExplosion(midX, midY, nextFruit.color);

                        // **ìƒˆ ìœ„ì¹˜ ê³„ì‚°: í•©ì³ì§„ ìœ„ì¹˜ë³´ë‹¤ ì‚´ì§ ìœ„**
                        // ê³¼ì¼ ë°˜ì§€ë¦„ë§Œí¼ ìœ„ë¡œ ì˜¬ë ¤ì„œ ìƒì„±í•˜ë©´ ìì—°ìŠ¤ëŸ½ê²Œ ë–¨ì–´ì§
                        const spawnY = midY - nextFruit.radius * 0.5;

                        const newBody = addFruitBody(midX, spawnY, nextFruit.index);
                        
                        // **ìƒì„± ì‹œ ìœ„ë¡œ ì‚´ì§ íŠ€ì–´ì˜¤ë¥´ëŠ” í˜ ë¶€ì—¬ (Pop íš¨ê³¼)**
                        Body.setVelocity(newBody, { x: 0, y: -3 });
                        
                        updateScore(nextFruit.score * 2);
                    }
                }
            }
        });

        setInterval(checkGameOver, 1000);

        Runner.run(Runner.create(), engine);
        Render.run(render);

        prepareNextFruit();
    }

    // --- íŒŒí‹°í´ ì‹œìŠ¤í…œ ---
    function createExplosion(x, y, color) {
        // íŒŒí‹°í´ 10ê°œ ìƒì„±
        for (let i = 0; i < 12; i++) {
            particles.push({
                x: x,
                y: y,
                radius: Math.random() * 5 + 2, // í¬ê¸° ëœë¤
                color: color,
                velocity: {
                    x: (Math.random() - 0.5) * 10, // ì‚¬ë°©ìœ¼ë¡œ í¼ì§
                    y: (Math.random() - 0.5) * 10
                },
                alpha: 1.0, // íˆ¬ëª…ë„
                life: 1.0 // ìˆ˜ëª…
            });
        }
    }

    function updateAndDrawParticles(ctx) {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            
            // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            p.x += p.velocity.x;
            p.y += p.velocity.y;
            
            // ì¤‘ë ¥ ì˜í–¥ (ì‚´ì§ ì•„ë˜ë¡œ ë–¨ì–´ì§€ê²Œ)
            p.velocity.y += 0.2;
            
            // ìˆ˜ëª… ê°ì†Œ
            p.life -= 0.02;
            p.alpha = p.life;

            if (p.life <= 0) {
                particles.splice(i, 1);
                continue;
            }

            // ê·¸ë¦¬ê¸°
            ctx.globalAlpha = p.alpha;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    function addFruitBody(x, y, index) {
        const fruit = FRUITS[index];
        const body = Bodies.circle(x, y, fruit.radius, {
            label: fruit.name,
            restitution: 0.2, 
            friction: 0.1,
            density: 0.001, 
            render: { fillStyle: fruit.color }
        });
        Composite.add(engine.world, body);
        return body;
    }

    function prepareNextFruit() {
        if (gameOver) return;
        
        const index = nextFruitIndex;
        nextFruitIndex = Math.floor(Math.random() * 5); 
        
        document.getElementById('next-fruit-emoji').textContent = FRUITS[nextFruitIndex].emoji;

        currentFruit = {
            index: index,
            x: width / 2,
            y: 50
        };
        isDropping = false;
    }

    // --- ì…ë ¥ í•¸ë“¤ëŸ¬ ë° ìì´ë¡œ ì„¼ì„œ ---

    function requestMotionPermission() {
        if (isGyroEnabled) return;

        // iOS 13+ ê¶Œí•œ ìš”ì²­
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                        isGyroEnabled = true;
                        document.getElementById('permission-hint').style.display = 'none';
                    }
                })
                .catch(console.error);
        } else {
            // ì•ˆë“œë¡œì´ë“œ ë° êµ¬í˜• iOS
            window.addEventListener('deviceorientation', handleOrientation);
            isGyroEnabled = true;
            document.getElementById('permission-hint').style.display = 'none';
        }
    }

    function handleOrientation(event) {
        if (!engine || gameOver) return;

        // gamma: ì¢Œìš° ê¸°ìš¸ê¸° (-90 ~ 90)
        let gamma = event.gamma; 
        
        if (gamma === null) return;

        // ê°’ì„ -30 ~ 30 ì •ë„ë¡œ ì œí•œí•˜ì—¬ ë„ˆë¬´ ì‹¬í•˜ê²Œ ì ë¦¬ì§€ ì•Šê²Œ í•¨
        if (gamma > 30) gamma = 30;
        if (gamma < -30) gamma = -30;

        // ë¯¼ê°ë„ ì¡°ì ˆ (ì•„ì£¼ ì•½í•˜ê²Œ)
        // Matter.jsì˜ ê¸°ë³¸ gravity.yëŠ” 1ì…ë‹ˆë‹¤.
        // gravity.xë¥¼ 0.5 ì •ë„ë¡œë§Œ ì¤˜ë„ ê½¤ ë§ì´ ì ë¦½ë‹ˆë‹¤.
        // ë”°ë¼ì„œ gamma ê°’ì„ ì•„ì£¼ ì‘ê²Œ ë‚˜ëˆ•ë‹ˆë‹¤.
        const sensitivity = 0.02; // ë¯¼ê°ë„
        const gravityX = gamma * sensitivity;

        // ì¤‘ë ¥ ì ìš©
        engine.world.gravity.x = gravityX;
    }

    function handleInputStart(e) {
        // ì²« ì¸í„°ë™ì…˜ ì‹œ ìì´ë¡œ ê¶Œí•œ ìš”ì²­ ì‹œë„
        requestMotionPermission();

        if (isDropping || gameOver) return;
        updateCurrentFruitPos(e);
    }

    function handleInputMove(e) {
        if (isDropping || gameOver) return;
        updateCurrentFruitPos(e);
    }

    function handleInputEnd(e) {
        if (isDropping || gameOver) return;
        dropFruit();
    }

    function updateCurrentFruitPos(e) {
        if (!currentFruit) return;
        
        let clientX;
        if (e.type.includes('touch')) {
            clientX = e.touches[0].clientX;
        } else {
            clientX = e.clientX;
        }

        const rect = gameContainer.getBoundingClientRect();
        let x = clientX - rect.left;

        const radius = FRUITS[currentFruit.index].radius;
        x = Math.max(radius + 10, Math.min(width - radius - 10, x));

        currentFruit.x = x;
    }

    function dropFruit() {
        if (!currentFruit) return;
        isDropping = true;

        addFruitBody(currentFruit.x, currentFruit.y, currentFruit.index);
        currentFruit = null;

        setTimeout(prepareNextFruit, 800);
    }

    function updateScore(points) {
        score += points;
        document.getElementById('score').textContent = score;
    }

    function checkGameOver() {
        if (gameOver) return;
        
        const bodies = Composite.allBodies(engine.world);
        for (let i = 0; i < bodies.length; i++) {
            const body = bodies[i];
            if (!body.isStatic && body.position.y < TOP_BUFFER && body.speed < 0.2) {
                if(body.position.y > 40) { 
                    endGame();
                    break;
                }
            }
        }
    }

    function endGame() {
        gameOver = true;
        document.getElementById('game-over').style.display = 'flex';
    }

    function resetGame() {
        Composite.clear(engine.world);
        Engine.clear(engine);
        score = 0;
        updateScore(0);
        gameOver = false;
        particles = []; // íŒŒí‹°í´ ì´ˆê¸°í™”
        document.getElementById('game-over').style.display = 'none';
        
        // ì¤‘ë ¥ ì´ˆê¸°í™”
        engine.world.gravity.x = 0;
        engine.world.gravity.y = 1;
        
        const ground = Bodies.rectangle(width / 2, height + WALL_THICKNESS / 2 - 10, width, WALL_THICKNESS, { isStatic: true, render: { fillStyle: '#b2bec3' } });
        const leftWall = Bodies.rectangle(0 - WALL_THICKNESS / 2, height / 2, WALL_THICKNESS, height * 2, { isStatic: true, render: { fillStyle: '#b2bec3' } });
        const rightWall = Bodies.rectangle(width + WALL_THICKNESS / 2, height / 2, WALL_THICKNESS, height * 2, { isStatic: true, render: { fillStyle: '#b2bec3' } });
        const dangerLine = Bodies.rectangle(width/2, TOP_BUFFER, width, 2, { isStatic: true, isSensor: true, render: { fillStyle: '#fab1a0', opacity: 0.5 } });
        
        Composite.add(engine.world, [ground, leftWall, rightWall, dangerLine]);

        prepareNextFruit();
    }

    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    window.addEventListener('mousedown', handleInputStart);
    window.addEventListener('mousemove', handleInputMove);
    window.addEventListener('mouseup', handleInputEnd);

    window.addEventListener('touchstart', handleInputStart, {passive: false});
    window.addEventListener('touchmove', handleInputMove, {passive: false});
    window.addEventListener('touchend', handleInputEnd);

    document.getElementById('restart-btn').addEventListener('click', resetGame);
    
    window.addEventListener('resize', function() {
        width = gameContainer.clientWidth;
        height = gameContainer.clientHeight;
        render.canvas.width = width;
        render.canvas.height = height;
    });

    init();

</script>
</body>
</html>

