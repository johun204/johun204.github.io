<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ìˆ˜ë°• ê²Œì„ (Watermelon Game)</title>
    <!-- Matter.js ë¬¼ë¦¬ ì—”ì§„ ë¡œë“œ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        /* CSS ìŠ¤íƒ€ì¼ë§ */
        body {
            margin: 0;
            padding: 0;
            background-color: #ffeaa7;
            overflow: hidden; /* ìŠ¤í¬ë¡¤ ë°©ì§€ */
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: none; /* ëª¨ë°”ì¼ í„°ì¹˜ ì‹œ ë¸Œë¼ìš°ì € ê¸°ë³¸ ë™ì‘ ë°©ì§€ */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 450px; /* ëª¨ë°”ì¼ í­ ì œí•œ */
            height: 100vh;
            background: #fff;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            flex-grow: 1; /* ë‚¨ì€ ê³µê°„ ì±„ìš°ê¸° */
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* í´ë¦­ì€ ìº”ë²„ìŠ¤ë¡œ í†µê³¼ */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* ì§„í™” ë‹¨ê³„ í‘œì‹œì¤„ */
        #evolution-bar {
            width: 95%;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            margin-top: 10px;
            padding: 5px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            border: 2px solid #fab1a0;
            pointer-events: none;
            z-index: 5;
        }
        
        .evo-item {
            font-size: 14px;
            opacity: 0.5;
            transition: opacity 0.3s, transform 0.3s;
        }
        
        /* í˜„ì¬ í•©ì³ì§„ ê³¼ì¼ ê°•ì¡° íš¨ê³¼ìš© í´ë˜ìŠ¤ */
        .evo-active {
            opacity: 1;
            transform: scale(1.5);
        }

        .header-info {
            display: flex;
            width: 100%;
            justify-content: space-between;
            padding: 10px 20px;
            box-sizing: border-box;
            align-items: flex-start;
        }

        .score-board {
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 20px;
            border-radius: 20px;
            text-align: center;
            border: 2px solid #fab1a0;
        }

        .score-label {
            font-size: 12px;
            color: #636e72;
            display: block;
        }
        
        #score {
            font-size: 24px;
            font-weight: bold;
            color: #2d3436;
        }

        #next-fruit-display {
            background: rgba(255,255,255,0.8);
            padding: 5px 10px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #ffeaa7;
            min-width: 50px;
        }
        #next-fruit-label {
            font-size: 10px;
            color: #636e72;
        }
        #next-fruit-emoji {
            font-size: 28px;
        }

        /* ì‹œì‘ í™”ë©´ ì˜¤ë²„ë ˆì´ (ê¶Œí•œ ìš”ì²­ìš©) */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 234, 167, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
        }

        #start-btn {
            padding: 15px 40px;
            font-size: 24px;
            background-color: #ff7675;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 0 #d63031;
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #gyro-status {
            margin-top: 15px;
            font-size: 14px;
            color: #636e72;
        }

        /* ê²Œì„ ì˜¤ë²„ í™”ë©´ */
        #game-over {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            flex-direction: column;
            pointer-events: auto;
            z-index: 10;
        }

        #game-over h1 {
            color: white;
            font-size: 40px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #restart-btn {
            padding: 15px 30px;
            font-size: 20px;
            background-color: #fab1a0;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 0 #e17055;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui-layer">
        <!-- ì§„í™” ìˆœì„œë„ -->
        <div id="evolution-bar">
            <!-- ìë°”ìŠ¤í¬ë¦½íŠ¸ë¡œ ì±„ì›Œì§ -->
        </div>

        <div class="header-info">
            <div class="score-board">
                <span class="score-label">SCORE</span>
                <span id="score">0</span>
            </div>
            
            <div id="next-fruit-display">
                <div id="next-fruit-label">NEXT</div>
                <div id="next-fruit-emoji">ğŸ’</div>
            </div>
        </div>
    </div>
    
    <!-- ì‹œì‘ í™”ë©´ (ê¶Œí•œ ìš”ì²­ì„ ìœ„í•œ í•„ìˆ˜ ë‹¨ê³„) -->
    <div id="start-screen">
        <h1>ğŸ‰ ìˆ˜ë°• ê²Œì„</h1>
        <p style="margin-bottom: 30px; color: #555;">ê°™ì€ ê³¼ì¼ì„ í•©ì³ ìˆ˜ë°•ì„ ë§Œë“œì„¸ìš”!</p>
        <button id="start-btn">ê²Œì„ ì‹œì‘í•˜ê¸°</button>
        <div id="gyro-status">ê¸°ìš¸ê¸° ì„¼ì„œ ì‚¬ìš© ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.</div>
    </div>

    <div id="game-over">
        <h1>ê²Œì„ ì¢…ë£Œ!</h1>
        <button id="restart-btn">ë‹¤ì‹œ í•˜ê¸°</button>
    </div>
</div>

<script>
    // --- ê²Œì„ ì„¤ì • ë° ë°ì´í„° ---
    const FRUITS = [
        { index: 0, name: "cherry",     radius: 15,  score: 0,   color: "#FF0000", emoji: "ğŸ’" },
        { index: 1, name: "strawberry", radius: 25,  score: 10,  color: "#FF6666", emoji: "ğŸ“" },
        { index: 2, name: "grape",      radius: 35,  score: 20,  color: "#9933FF", emoji: "ğŸ‡" },
        { index: 3, name: "dekopon",    radius: 45,  score: 30,  color: "#FFAA00", emoji: "ğŸŠ" },
        { index: 4, name: "persimmon",  radius: 55,  score: 40,  color: "#FF7700", emoji: "ğŸ¥­" },
        { index: 5, name: "apple",      radius: 68,  score: 50,  color: "#FF2222", emoji: "ğŸ" },
        { index: 6, name: "pear",       radius: 80,  score: 60,  color: "#FFFF66", emoji: "ğŸ" },
        { index: 7, name: "peach",      radius: 95,  score: 70,  color: "#FFCCCC", emoji: "ğŸ‘" },
        { index: 8, name: "pineapple",  radius: 110, score: 80,  color: "#FFFF00", emoji: "ğŸ" },
        { index: 9, name: "melon",      radius: 130, score: 90,  color: "#99FF99", emoji: "ğŸˆ" },
        { index: 10, name: "watermelon",radius: 150, score: 100, color: "#00FF00", emoji: "ğŸ‰" },
    ];

    // Matter.js ëª¨ë“ˆ
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          Bodies = Matter.Bodies,
          Composite = Matter.Composite,
          Events = Matter.Events,
          Body = Matter.Body;

    // ì „ì—­ ë³€ìˆ˜
    let engine, render, runner;
    let currentFruit = null;
    let nextFruitIndex = 0;
    let isDropping = false;
    let score = 0;
    let gameOver = false;
    let particles = [];
    
    // DOM ìš”ì†Œ
    const gameContainer = document.getElementById('game-container');
    const startScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('start-btn');
    const gyroStatus = document.getElementById('gyro-status');
    const evoBar = document.getElementById('evolution-bar');

    let width = gameContainer.clientWidth;
    let height = gameContainer.clientHeight;
    
    const WALL_THICKNESS = 40;
    const TOP_BUFFER = 140; // ìƒë‹¨ UI ê³µê°„ë§Œí¼ ì—¬ìœ 

    // 1. ì§„í™” ì°¨íŠ¸ ìƒì„±
    function createEvolutionChart() {
        evoBar.innerHTML = '';
        FRUITS.forEach((fruit, idx) => {
            const span = document.createElement('span');
            span.textContent = fruit.emoji;
            span.className = 'evo-item';
            span.id = `evo-${idx}`;
            // ë§ˆì§€ë§‰ ìˆ˜ë°•ì€ ì¢€ ë” í¬ê²Œ
            if(idx === FRUITS.length-1) span.style.fontSize = '20px';
            evoBar.appendChild(span);
        });
    }

    // 2. ê²Œì„ ì‹œì‘ ë° ê¶Œí•œ ìš”ì²­ í•¸ë“¤ëŸ¬
    startBtn.addEventListener('click', async () => {
        // iOS 13+ ê¶Œí•œ ìš”ì²­ ë¡œì§ (ë°˜ë“œì‹œ í´ë¦­ ì´ë²¤íŠ¸ ë‚´ë¶€ì—¬ì•¼ í•¨)
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const permissionState = await DeviceOrientationEvent.requestPermission();
                if (permissionState === 'granted') {
                    window.addEventListener('deviceorientation', handleOrientation);
                    gyroStatus.textContent = "ì„¼ì„œ í™œì„±í™”ë¨!";
                } else {
                    gyroStatus.textContent = "ì„¼ì„œ ê¶Œí•œ ê±°ë¶€ë¨ (ì„¤ì • í™•ì¸ í•„ìš”)";
                }
            } catch (error) {
                console.error(error);
                gyroStatus.textContent = "ì„¼ì„œ ì˜¤ë¥˜";
            }
        } else {
            // ì•ˆë“œë¡œì´ë“œ ë“± ê¶Œí•œ ìš”ì²­ í•„ìš” ì—†ëŠ” ê²½ìš°
            window.addEventListener('deviceorientation', handleOrientation);
        }

        // í™”ë©´ ì „í™˜ ë° ê²Œì„ ì‹œì‘
        startScreen.style.display = 'none';
        initGame();
    });

    // 3. ìì´ë¡œ ì„¼ì„œ í•¸ë“¤ëŸ¬
    function handleOrientation(event) {
        if (!engine || gameOver) return;
        let gamma = event.gamma; // ì¢Œìš° ê¸°ìš¸ê¸°
        if (gamma === null) return;

        // ê°’ ì œí•œ (-30 ~ 30ë„)
        if (gamma > 30) gamma = 30;
        if (gamma < -30) gamma = -30;

        // ë¯¸ì„¸í•œ ì¤‘ë ¥ ì ìš©
        const sensitivity = 0.03; 
        engine.world.gravity.x = gamma * sensitivity;
    }

    // 4. ê²Œì„ ì´ˆê¸°í™”
    function initGame() {
        createEvolutionChart();

        engine = Engine.create();
        
        // ìº”ë²„ìŠ¤ê°€ ì´ë¯¸ ìˆë‹¤ë©´ ì‚­ì œ (ë¦¬ìŠ¤íƒ€íŠ¸ ì‹œ)
        const existingCanvas = gameContainer.querySelector('canvas');
        if (existingCanvas) existingCanvas.remove();

        render = Render.create({
            element: gameContainer,
            engine: engine,
            options: {
                width: width,
                height: height,
                wireframes: false,
                background: 'transparent'
            }
        });

        // ë²½ê³¼ ë°”ë‹¥
        const ground = Bodies.rectangle(width / 2, height + WALL_THICKNESS / 2 - 10, width, WALL_THICKNESS, { isStatic: true, render: { fillStyle: '#b2bec3' } });
        const leftWall = Bodies.rectangle(0 - WALL_THICKNESS / 2, height / 2, WALL_THICKNESS, height * 2, { isStatic: true, render: { fillStyle: '#b2bec3' } });
        const rightWall = Bodies.rectangle(width + WALL_THICKNESS / 2, height / 2, WALL_THICKNESS, height * 2, { isStatic: true, render: { fillStyle: '#b2bec3' } });
        
        // ê²Œì„ì˜¤ë²„ ë¼ì¸
        const dangerLine = Bodies.rectangle(width/2, TOP_BUFFER, width, 2, { 
            isStatic: true, 
            isSensor: true, 
            render: { fillStyle: '#fab1a0', opacity: 0.5 } 
        });

        Composite.add(engine.world, [ground, leftWall, rightWall, dangerLine]);

        // ë Œë”ë§ ë£¨í”„ ì„¤ì •
        Events.on(render, 'afterRender', renderLoop);
        
        // ì¶©ëŒ ì´ë²¤íŠ¸ ì„¤ì •
        Events.on(engine, 'collisionStart', handleCollision);

        // ê²Œì„ ì˜¤ë²„ ì²´í¬ ì¸í„°ë²Œ
        setInterval(checkGameOver, 1000);

        // ì‹¤í–‰
        Runner.run(Runner.create(), engine);
        Render.run(render);

        prepareNextFruit();

        // ì…ë ¥ ì´ë²¤íŠ¸ ë“±ë¡
        bindInputEvents();
    }

    // ë Œë”ë§ ë£¨í”„ (ê·¸ë¦¬ê¸° ë‹´ë‹¹)
    function renderLoop() {
        const context = render.context;
        const bodies = Composite.allBodies(engine.world);

        // ê³¼ì¼ ê·¸ë¦¬ê¸°
        for (let i = 0; i < bodies.length; i++) {
            const body = bodies[i];
            if (body.isStatic) continue;

            const fruitInfo = FRUITS.find(f => f.name === body.label);
            if (fruitInfo) {
                context.font = `${fruitInfo.radius * 1.5}px Arial`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.save();
                context.translate(body.position.x, body.position.y);
                context.rotate(body.angle);
                context.fillText(fruitInfo.emoji, 0, 5);
                context.restore();
            }
        }
        
        // íŒŒí‹°í´ ê·¸ë¦¬ê¸°
        updateAndDrawParticles(context);

        // ëŒ€ê¸° ì¤‘ì¸ ê³¼ì¼ ê·¸ë¦¬ê¸°
        if (currentFruit && !isDropping) {
            const info = FRUITS[currentFruit.index];
            context.beginPath();
            context.moveTo(currentFruit.x, TOP_BUFFER);
            context.lineTo(currentFruit.x, height);
            context.strokeStyle = 'rgba(0,0,0,0.1)';
            context.stroke();

            context.font = `${info.radius * 1.5}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(info.emoji, currentFruit.x, currentFruit.y);
        }
    }

    // ì¶©ëŒ ì²˜ë¦¬
    function handleCollision(event) {
        if (gameOver) return;

        const pairs = event.pairs;
        const removedBodies = new Set();

        for (let i = 0; i < pairs.length; i++) {
            const bodyA = pairs[i].bodyA;
            const bodyB = pairs[i].bodyB;

            if (removedBodies.has(bodyA.id) || removedBodies.has(bodyB.id)) continue;

            if (bodyA.label === bodyB.label) {
                const fruitIndex = FRUITS.findIndex(f => f.name === bodyA.label);
                
                if (fruitIndex !== -1 && fruitIndex < FRUITS.length - 1) {
                    const midX = (bodyA.position.x + bodyB.position.x) / 2;
                    const midY = (bodyA.position.y + bodyB.position.y) / 2;

                    removedBodies.add(bodyA.id);
                    removedBodies.add(bodyB.id);

                    Composite.remove(engine.world, [bodyA, bodyB]);
                    
                    const nextFruit = FRUITS[fruitIndex + 1];
                    
                    // íš¨ê³¼: íŒŒí‹°í´ + ìƒë‹¨ ì°¨íŠ¸ ê°•ì¡°
                    createExplosion(midX, midY, nextFruit.color);
                    highlightEvolution(nextFruit.index);

                    // ìƒì„± ìœ„ì¹˜: ì¶©ëŒ ì§€ì ë³´ë‹¤ ì•½ê°„ ìœ„
                    const spawnY = midY - nextFruit.radius * 0.5;
                    const newBody = addFruitBody(midX, spawnY, nextFruit.index);
                    
                    // íŒì—… íš¨ê³¼ (ìœ„ë¡œ ì‚´ì§)
                    Body.setVelocity(newBody, { x: 0, y: -4 });
                    
                    updateScore(nextFruit.score * 2);
                }
            }
        }
    }

    // ì§„í™” ë‹¨ê³„ ì¼ì‹œ ê°•ì¡°
    function highlightEvolution(index) {
        const el = document.getElementById(`evo-${index}`);
        if(el) {
            el.classList.add('evo-active');
            setTimeout(() => el.classList.remove('evo-active'), 300);
        }
    }

    function createExplosion(x, y, color) {
        for (let i = 0; i < 15; i++) {
            particles.push({
                x: x, y: y,
                radius: Math.random() * 6 + 2,
                color: color,
                velocity: { x: (Math.random() - 0.5) * 12, y: (Math.random() - 0.5) * 12 },
                alpha: 1.0, life: 1.0
            });
        }
    }

    function updateAndDrawParticles(ctx) {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.velocity.x;
            p.y += p.velocity.y;
            p.velocity.y += 0.3; // ì¤‘ë ¥
            p.life -= 0.03;
            p.alpha = p.life;

            if (p.life <= 0) {
                particles.splice(i, 1);
                continue;
            }

            ctx.globalAlpha = p.alpha;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    function addFruitBody(x, y, index) {
        const fruit = FRUITS[index];
        const body = Bodies.circle(x, y, fruit.radius, {
            label: fruit.name,
            restitution: 0.2,
            friction: 0.1,
            density: 0.001,
            render: { fillStyle: fruit.color }
        });
        Composite.add(engine.world, body);
        return body;
    }

    function prepareNextFruit() {
        if (gameOver) return;
        const index = nextFruitIndex;
        nextFruitIndex = Math.floor(Math.random() * 5);
        document.getElementById('next-fruit-emoji').textContent = FRUITS[nextFruitIndex].emoji;
        
        // ì°¨íŠ¸ì—ì„œ ë‹¤ìŒ ê³¼ì¼ ê°•ì¡°
        document.querySelectorAll('.evo-item').forEach(el => el.style.opacity = '0.5');
        const nextEl = document.getElementById(`evo-${nextFruitIndex}`);
        if(nextEl) nextEl.style.opacity = '1.0';

        currentFruit = { index: index, x: width / 2, y: 50 };
        isDropping = false;
    }

    // ì…ë ¥ ì´ë²¤íŠ¸
    function bindInputEvents() {
        window.addEventListener('mousedown', handleInputStart);
        window.addEventListener('mousemove', handleInputMove);
        window.addEventListener('mouseup', handleInputEnd);

        // passive: falseëŠ” ìŠ¤í¬ë¡¤ ë§‰ê¸° ìœ„í•´ í•„ìˆ˜
        window.addEventListener('touchstart', handleInputStart, {passive: false});
        window.addEventListener('touchmove', handleInputMove, {passive: false});
        window.addEventListener('touchend', handleInputEnd);
    }

    function handleInputStart(e) {
        if (isDropping || gameOver) return;
        updateCurrentFruitPos(e);
    }
    function handleInputMove(e) {
        if (isDropping || gameOver) return;
        updateCurrentFruitPos(e);
    }
    function handleInputEnd(e) {
        if (isDropping || gameOver) return;
        dropFruit();
    }

    function updateCurrentFruitPos(e) {
        if (!currentFruit) return;
        let clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
        const rect = gameContainer.getBoundingClientRect();
        let x = clientX - rect.left;
        const radius = FRUITS[currentFruit.index].radius;
        // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ì§€ ì•Šê²Œ
        x = Math.max(radius + 5, Math.min(width - radius - 5, x));
        currentFruit.x = x;
    }

    function dropFruit() {
        if (!currentFruit) return;
        isDropping = true;
        addFruitBody(currentFruit.x, currentFruit.y, currentFruit.index);
        currentFruit = null;
        setTimeout(prepareNextFruit, 600);
    }

    function updateScore(points) {
        score += points;
        document.getElementById('score').textContent = score;
    }

    function checkGameOver() {
        if (gameOver) return;
        const bodies = Composite.allBodies(engine.world);
        for (let i = 0; i < bodies.length; i++) {
            const body = bodies[i];
            if (!body.isStatic && body.position.y < TOP_BUFFER && body.speed < 0.2) {
                if(body.position.y > 60) { // ìƒì„± ìœ„ì¹˜ ê·¼ì²˜ë©´ ì œì™¸
                    endGame();
                    break;
                }
            }
        }
    }

    function endGame() {
        gameOver = true;
        document.getElementById('game-over').style.display = 'flex';
    }

    document.getElementById('restart-btn').addEventListener('click', () => {
        Composite.clear(engine.world);
        Engine.clear(engine);
        score = 0;
        updateScore(0);
        gameOver = false;
        particles = [];
        document.getElementById('game-over').style.display = 'none';
        
        // ì¤‘ë ¥ ì´ˆê¸°í™”
        engine.world.gravity.x = 0;
        
        // ë²½ ì¬ìƒì„± ë¡œì§ ë“±ì€ initGameì—ì„œ ì²˜ë¦¬í•˜ë¯€ë¡œ ì¬í˜¸ì¶œ
        initGame();
    });

    // ë¦¬ì‚¬ì´ì¦ˆ
    window.addEventListener('resize', () => {
        width = gameContainer.clientWidth;
        height = gameContainer.clientHeight;
        if(render) {
            render.canvas.width = width;
            render.canvas.height = height;
        }
    });

</script>
</body>
</html>

